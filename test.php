<?php

/**
 * This file contains a framework that demonstrates a different approach to writing HTML that is generated by PHP.
 * It uses MVC concepts, as well as abstraction, inheritance, and dependency inversion to programmatically generate
 * the HTML, and can easily be extended to add custom views.
 */
//These are the interfaces and abstract classes needed
//This is the root view
interface View {

    /** Returns the rendered content as a string */
    public function render();

    /** Shortcut to running: echo $this->render(); */
    public function display();
}

class CSSSelectors {

    private static $selectors = array();
    //Maps child(key) to parent(value)
    private static $inheritance = array();

    public static function addSelector($parent, $name, array $attributes) {
        //TODO: Check for invalid characters in the parent or name
        //Walk through our attributes and check for illegal characters
        foreach ($attributes as $key => $value) {
            $illegalRegex = '/[:;]/';
            if (preg_match($illegalRegex, $key) || preg_match($illegalRegex, $value)) {
                trigger_error("Illegal character in attribute list: '" . $key . "' or '" . $value . "'\n<br />You many not include any characters that"
                        . " match the following regex: $illegalRegex. Special characters are inserted for you", E_USER_WARNING);
            }
        }
        $selectors = self::standardizeCSSSelector($name);
        foreach ($selectors as $name) {
            if (isset(self::$selectors[$name])) {
                //It's already set, so just append these attributes
                foreach ($attributes as $prop => $value) {
                    self::$selectors[$name][$prop] = $value;
                }
            } else {
                //It's new, just set it
                self::$selectors[$name] = $attributes;
                if ($parent != null) {
                    self::$inheritance[$name] = $parent;
                }
            }
        }
    }

    public static function render() {
        $rendered = "";
        foreach (array_keys(self::$selectors) as $name) {
            $attributes = self::collectAttributes($name);
            $rendered .= "$name {\n";
            foreach ($attributes as $name => $value) {
                $rendered .= "\t$name: $value;\n";
            }
            $rendered .= "}\n\n";
        }
        return $rendered;
    }

    private static function collectAttributes($name) {
        $attributes = array();
        $hierarchy = array();
        array_push($hierarchy, $name);
        $find = $name;
        while (array_key_exists($find, self::$inheritance)) {
            //Avoid inheritance loops			
            if (in_array($find, $hierarchy)) {
                break;
            }
            array_push($hierarchy, $find);
            $find = self::$inheritance[$find];
        }
        while (($popped = array_pop($hierarchy)) !== null) {
            foreach (self::$selectors[$popped] as $key => $value) {
                //Merging this way allows for overridding properties
                $attributes[$key] = $value;
            }
        }
        return $attributes;
    }

    /**
     * Returns an array of standardized css names, that is, a name with extra spaces is removed.
     * The name is split on commas first, which allows for more granular control of the names.
     * @param type $selector 
     */
    private static function standardizeCSSSelector($selector) {
        $names = preg_split("/,/", $selector);
        $final = array();
        foreach ($names as $name) {
            $name = trim($name);
            if ($name == "") {
                continue;
            }
            //Standardize + and > with exactly one space on either side of it, so h1>h2 turns into h1 > h2
            $name = preg_replace('/>/', " > ", $name);
            $name = preg_replace('/\+/', " + ", $name);
            $name = preg_replace('/\s{2,}/', " ", $name);
            $final[] = $name;
        }
        return $final;
    }

}

//This is the root HTMLView. There might be other views, such as an XMLView.
abstract class HTMLView implements View {

    private $externalScripts = null;
    private $internalScripts = null;
    private $externalCSS = null;
    private $metaTags = null;
    private $title = null;
    private $customCSS = null;

    /**
     * This appends fully custom css exactly as provided to the <style> tag in the head.
     * It is preferred to use addCSSBlock instead, which provides better granularity.
     * @param type $css 
     */
    public function appendRawCSS($css) {
        $this->customCSS = "\n" . $css;
        return $this;
    }

    public function getRawCSS() {
        return $this->customCSS;
    }

    /**
     * This adds a css selector block to the <style> tag in the <head> of the document. $name is the
     * css selector, i.e. #id, or .class. More complex selectors are also supported, the name is
     * put in as is. Multiple values at once are supported, i.e. "h1, h2".
     * @param type $name The name of the css selector
     * @param array $components An associative array of selector properties
     */
    public function addCSSBlock($name, array $components) {
        CSSSelectors::addSelector(null, $name, $components);
        return $this;
    }

    /**
     * Typically, CSS does not have inheritance. However, using this method will allow a selector to inherit
     * from another selector. Say you have two selectors:
     * .class1{
     *     border: solid black 1px;
     * }
     * .class2{
     *     background-color: white;
     * }
     * If you want the properties in class1 to be "absorbed" into class2, call this method as follows:
     * inheritCSSBlock(".class1", ".class2", array("background-color", "white"));
     * The inheritance isn't resolved until the page is rendered, so the parent element needn't exist
     * yet.
     * @param type $parent
     * @param type $name
     * @param array $components 
     */
    public function inheritCSSBlock($parent, $name, array $components) {
        CSSSelectors::addSelector($parent, $name, $components);
        return $this;
    }

    //A default implementation is provided, though it can be overridden by a subclass if needed, or if there's not even a chance that would make sense, we could make it final
    public function display() {
        echo $this->render();
    }

    /**
     * Adds a script that will get added to the head of a page, as an externally linked script.
     * @param string $script 
     */
    final public function addExternalScript($script) {
        if ($this->externalScripts === null) {
            $this->externalScripts = array();
        }
        if (!in_array($script, $this->externalScripts)) {
            $this->externalScripts[] = $script;
        }
        return $this;
    }

    /**
     * Adds a script that will get added as an inline script
     * @param string $script 
     */
    final protected function addInlineScript($script) {
        //We must separate scripts with newlines, so that line comments from the previous script don't affect this script
        $this->internalScripts .= $script . "\n";
        return $this;
    }

    final public function addExternalCSS($href) {
        if ($this->externalCSS === null) {
            $this->externalCSS = array();
        }
        if (!in_array($href, $this->externalCSS)) {
            $this->externalCSS[] = $href;
        }
        return $this;
    }

    final public function getExternalCSS() {
        if ($this->externalCSS === null) {
            $this->externalCSS = array();
        }
        return $this->externalCSS;
    }

    final public function addMetaTag(HTMLMeta $meta) {
        if ($this->metaTags === null) {
            $this->metaTags = array();
        }
        $this->metaTags[] = $meta;
        return $this;
    }

    final public function getMetaTags() {
        if ($this->metaTags === null) {
            $this->metaTags = array();
        }
        return $this->metaTags;
    }

    /**
     * Gets the external scripts linked to by this element
     * @return array
     */
    final public function getExternalScripts() {
        if ($this->externalScripts === null) {
            $this->externalScripts = array();
        }
        return $this->externalScripts;
    }

    /**
     * Gets the inline scripts needed by this element
     * @return string
     */
    final public function getInlineScripts() {
        return $this->internalScripts;
    }

    /**
     * Sets the title of this page. If $title is null, it is ignored.
     * @param type $title 
     */
    final public function setPageTitle($title) {
        if ($title === null) {
            return;
        }
        if ($this->title !== null) {
            trigger_warning("Setting page title more than once! Was {$this->title} but now is $title", E_USER_WARNING);
        }
        $this->title = $title;
        return $this;
    }

    final public function getTitle() {
        return $this->title;
    }

    /**
     * Given a view, assimilates the HTMLView level information into this object.
     * @param HTMLView $view 
     */
    final protected function extract(HTMLView $view) {
        if ($view->externalScripts !== null) {
            foreach ($view->externalScripts as $exScript) {
                $this->addExternalScript($exScript);
            }
        }
        if ($view->externalCSS !== null) {
            foreach ($view->externalCSS as $exCSS) {
                $this->addExternalCSS($exCSS);
            }
        }
        $this->addInlineScript($view->internalScripts . "\n");
        $this->setPageTitle($view->title);
        $this->customCSS .= ($this->customCSS != "" ? "\n" : "") . $view->customCSS;
    }

}

/**
 * An HTMLContainer can encapsulate any content, but allows for attributes to be added to the html element.
 * Basic elements would probably use HTMLBlock or HTMLInline as the actual implementation.
 */
abstract class HTMLContainer extends HTMLView {

    /**
     * This array contains a list of the known ids in this heirarchy
     * @var type 
     */
    private $knownIDs = array();

    /**
     * If this container's tag should self close if there is no content
     * @var type 
     */
    protected $selfClosed = true;

    /** These are the custom attributes */
    private $attributes;
    private $styles;
    private static $randID = null;

    /**
     * Sometimes complex components need to generate a random ID to assign to automatically generated
     * and managed components. This method returns a (more than likely) guaranteed unique id, across
     * all runs of the script.
     */
    public static function getRandomId() {
        if (self::$randID === null) {
            self::$randID = (int) (rand(10, 1000) + time()) / 1000;
        }
        $id = self::$randID++;
        return "autoGenID_" . $id;
    }

    /**
     * As a convenience to simple classes, the $content variable may be used to store contained data, which
     * is returned by getContent() by default. 
     * @var mixed
     */
    protected $content = null;

    protected function __construct($content) {
        if (!($content instanceof HTMLView)) {
            $content = new HTMLText($content);
        }
        $this->content = $content;
        $this->extract($content);
    }

    protected function isSelfClosingSupported() {
        return $this->selfClosed;
    }

    /** Sets the specified attribute, overwriting the old one if already set */
    final public function setAttribute($name, $content) {
        $this->removeAttribute($name);
        if ($name == "id") {
            unset($this->knownIDs[spl_object_hash($this)]);
            //Check for duplicate ids 
            if (in_array($content, $this->knownIDs)) {
                trigger_error("Duplicate id being added to an element! \"" . $content . '"', E_USER_WARNING);
            }
            $this->knownIDs[spl_object_hash($this)] = $content;
        }
        self::appendAttribute($name, $content);
        return $this;
    }

    final public function removeAttribute($name) {
        if ($this->attributes === null) {
            $this->attributes = array();
        }
        if ($name == "id") {
            unset($this->knownIDs[spl_object_hash($this)]);
        }
        unset($this->attributes[$name]);
        return $this;
    }

    /**
     * Returns the value stored in a specific attribute.
     * @param string $name
     * @return mixed Null if the attribute isn't added, or the contents if it has
     */
    final public function getAttribute($name) {
        if ($this->attributes === null) {
            $this->attributes = array();
        }
        if (isset($this->attributes[$name])) {
            return $this->attributes[$name];
        } else {
            return null;
        }
    }

    /**
     * Convenience method to set the id of this element
     * @param type $id 
     */
    public function setId($id) {
        $this->setAttribute("id", $id);
        return $this;
    }

    /**
     * Convenience method to add a class to this element
     * @param type $class 
     */
    public function addClass($class) {
        $this->appendAttribute("class", $class);
        return $this;
    }

    /**
     * Convenience method to add a style to this element. The caller of this
     * method need not worry about separating it from the existing content, it will be added properly, that is,
     * the semi-colon will be added only if necessary, but will be done automatically.
     */
    public function addStyle($style, $value) {
        if ($this->styles === null) {
            $this->styles = array();
        }
        $this->styles[$style] = $value;
        return $this;
    }

    private static $coreAttributesDisallowed = array("base", "head", "html", "meta", "param", "script", "style", "title");
    private static $coreAttributes = array("class", "id", "style", "title");
    private static $languageAttributesDisallowed = array("base", "br", "frame", "frameset", "hr", "iframe", "param", "script");
    private static $languageAttributes = array("dir", "lang", "xml:lang");

    /**
     * Checks to see if any disallowed attributes are being added, based on this element name
     * @param type $attributeName 
     */
    private function checkAttribute($attributeName) {
        $me = $this->getTagName();
        $trigger = false;
        if (in_array($attributeName, self::$coreAttributes)) {
            if (in_array($me, self::$coreAttributesDisallowed)) {
                $trigger = true;
            }
        }
        if (in_array($attributeName, self::$languageAttributes)) {
            if (in_array($me, self::$languageAttributesDisallowed)) {
                $trigger = true;
            }
        }

        if ($trigger) {
            trigger_error("The attribute '$attributeName' is not allowed in $me tags", E_USER_WARNING);
        }
    }

    /**
     * Appends the content to the specified attribute, creating it first if it doesn't exist. For the special	  
     * case of the style attribute, puts a ; between the existing content and the new content. Subclasses
     * may override this method to do more specific checks on attributes added to an element. Note that
     * setting an attribute is the same as removing the attribute, then appending it.
     * 
     * Note to subclass implementers: You should call parent::appendAttribute for all attributes you aren't
     * specially handling, and you should use it to actually add the attribute as well, or setAttribute.
     */
    public function appendAttribute($name, $content) {
        $name = trim(strtolower($name));
        $this->checkAttribute($name);
        if ($name == "id" && isset($this->attributes['id'])) {
            //It doesn't make sense to append to an id, so trigger a warning
            trigger_error("Attempting to append to the id attribute", E_USER_WARNING);
        }
        if ($name == "style") {
            trigger_error("You shouldn't use appendAttribute to add styles. Use addStyle instead.", E_USER_WARNING);
        }
        if ($name == "class") {
            //Look at the existing content to see if it already has a space at the end. If not, add a space first
            if (isset($this->attributes["class"])) {
                $content = $this->attributes["class"] . " " . $content;
                $classes = array();
                foreach (preg_split("/[ ]+/", $content) as $class) {
                    $classes[] = $class;
                }
                $content = implode(" ", array_unique($classes));
            }
        }
        //We give special treatment to the standard HTML attributes,
        //such as id, class, style, and title, since we can be smarter about them
        if ($name === "id") {
            $this->attributes[$name] = $content;
            return;
        }

        if (in_array($name, $this->attributes)) {
            $this->attributes[$name] = $this->attributes[$name] . $content;
            return;
        }
        $this->attributes[$name] = $content;
        return $this;
    }

    /**
     * Convenience method to set an associative array of attributes
     * @param type $attributes 
     */
    final public function addAttributeArray($attributes) {
        foreach ($attributes as $name => $content) {
            $this->appendAttribute($name, $content);
        }
        return $this;
    }

    private function renderStyles() {
        return self::SRenderStyles($this->styles);
    }

    public static final function SRenderStyles($styleArray) {
        if ($styleArray == null) {
            return null;
        }
        $first = true;
        $rendered = "";
        foreach ($styleArray as $style => $value) {
            if (!$first) {
                $rendered .= "; ";
            }
            $rendered .= "$style: $value";
            $first = false;
        }
        return $rendered;
    }

    /**
     * Renders out the attribute set. Uses $this->attributes if $attributes is null. If the attribute
     * list is empty (or null), null is returned. Attributes are properly escaped at this point,
     * so they don't need to actually be escaped elsewhere.
     * @return type 
     */
    final protected function renderAttributes($attributes = null) {
        if ($attributes === null) {
            $attributes = $this->attributes;
            $renderedStyles = $this->renderStyles();
            if ($renderedStyles !== null) {
                $attributes["style"] = $renderedStyles;
            }
        }
        return self::SRenderAttributes($attributes);
    }

    public static final function SRenderAttributes($attributes) {
        if ($attributes === null) {
            return null;
        }
        if ($attributes !== null && !is_array($attributes)) {
            throw new Exception("Value passed to renderAttributes is not an array or null");
        }
        if ($attributes === null || count($attributes) === 0) {
            //No attributes on this element
            return null;
        }
        $result = "";
        foreach ($attributes as $name => $content) {
            //We need to escape the special characters in the content
            $result .= $name . '="' . htmlentities($content) . '" ';
        }
        return trim($result);
    }

    /** Gets the content of this item, which is used in the default implementation of render(). If this
      returns null, the tag will be self closed if that option is set. By default, returns $content, which
      is by default null. */
    protected function getContent() {
        return $this->content;
    }

    /**
     * Returns the tag name, which is used by the default implementation of render. 
     */
    abstract protected function getTagName();

    /**
     * The default implementation of render returns the generated HTML, based on tag name provided by getTagName,
     * any attributes added to the component, and the contents returned by getContent.
     * @return string 
     */
    public function render() {
        $content = $this->getContent();
        if ($content instanceof HTMLView) {
            $content = $content->render();
        }
        if ($this->getTagName() === null) {
            return $content;
        }
        $attributes = $this->renderAttributes();

        $rendered = "<" . $this->getTagName();
        if ($attributes !== null) {
            $rendered .= " $attributes";
        }
        if ($content === null && $this->selfClosed) {
            $rendered .= " />";
            return $rendered;
        } else {
            $rendered .= ">";
            $rendered .= $content
                    . "</" . $this->getTagName() . ">";
        }
        return $rendered;
    }

}

/**
 * A view may contain several other views, but itself not be a container. This class knows how to contain several
 * elements, but it will not add an outer container to the child elements. It will
 * however extract <head> information, and pass it up the chain. The getContent method can be overridden and $views
 * can manually be rendered if need be.
 */
abstract class HTMLFlatComposite extends HTMLContainer {

    protected $views = array();

    /**
     * Initializes the HTMLFlatComposite parent. If $views is null, it is ignored, if it is a single HTMLView it is added
     * to the view list, if it's not an HTMLView object, it is put into an HTMLText object, then added, and if it's
     * an array of HTMLViews, it is walked through and each view is added.
     * @param type $views
     * @param HTMLContainer $container The container for the content.
     * @return type 
     */
    protected function __construct($views = null) {
        $this->construct0(func_get_args());
    }

    private function construct0() {
        foreach (func_get_args() as $arg) {
            if ($arg === null) {
                continue;
            }
            if (is_array($arg)) {
                foreach ($arg as $view) {
                    $this->construct0($view);
                }
            } else {
                $this->addView0($arg);
            }
        }
    }

    private function addView0($view) {
        if ($view instanceof HTMLView) {
            $this->addView($view);
        } else {
            $this->addView(new HTMLText($view));
        }
    }

    /**
     * Adding a view here will extract up the information contained in the view, so that extractable information is
     * carried up all the way. Implementing classes may want to expose this method as public, but should call
     * this class's method first.
     * @param HTMLView $view 
     */
    protected function addView(HTMLView $view) {
        $this->views[] = $view;
        $this->extract($view);
        return $this;
    }

    protected function getContent() {
        $content = "";
        foreach ($this->views as $view) {
            $content .= $view->render();
        }
        if (trim($content) == "") {
            return null;
        }
        $content = new HTMLRaw($content);
        return $content;
    }

    protected function getTagName() {
        return null;
    }

    /**
     * Recurses down into all the children in this view, and returns them all as a flat list
     * @return array 
     */
    protected function getAllViews() {
        $views = array();
        $this->getAllViews0($views);
        return $views;
    }

    private function getAllViews0(&$views) {
        $views[] = $this;
        foreach ($this->views as $view) {
            if ($view instanceof HTMLFlatComposite) {
                $view->getAllViews0($views);
            } else {
                $views[] = $view;
            }
        }
    }

}

/** An HTML Composite class encapsulates several HTMLContainer views into one, and is the basis for more complex html structures */
abstract class HTMLComposite extends HTMLFlatComposite {

    protected function getTagName() {
        return $this->getCompositeTagName();
    }

    protected abstract function getCompositeTagName();
}

/**
 * Classes that extend HTMLContainer will by default
 * add non-HTMLView content as a HTMLText view. If this
 * is not desired, this class may be used to wrap
 * the content. Typically, you should not use
 * this class directly however, you should decide
 * why you need to treat this content as a raw HTML,
 * and make a class for it. 
 */
class HTMLRaw extends HTMLView {

    private $content;

    public function __construct($content) {
        $this->content = $content;
    }

    public function render() {
        return $this->content;
    }

}

class HTMLMeta extends HTMLContainer {

    public function __construct($content, $name = null, $http_equiv = null, $scheme = null) {
        $this->setAttribute("content", $content);
        if ($name !== null) {
            $this->setAttribute("name", $name);
        }
        if ($http_equiv !== null) {
            $this->setAttribute("http-equiv", $http_equiv);
        }
        if ($scheme !== null) {
            $this->setAttribute("scheme", $scheme);
        }
    }

    public function appendAttribute($name, $content) {
        switch ($name) {
            case "name":
                if ($this->getAttribute("http-equiv") != null) {
                    trigger_error("Adding 'name' attribute to HTMLMeta, when 'http-equiv' attribute already exists", E_USER_WARNING);
                }
                $this->removeAttribute("name");
                break;
            case "http-equiv":
                if ($this->getAttribute("name") != null) {
                    trigger_error("Adding 'http-equiv' attribute to HTMLMeta, when 'name' attribute already exists", E_USER_WARNING);
                }
                $this->removeAttribute("http-equiv");
                break;
            case "scheme":
                $this->removeAttribute("scheme");
                break;
            default:
                break;
        }
        parent::appendAttribute($name, $content);
        return $this;
    }

    protected function getContent() {
        if ($this->getAttribute("http-equiv") !== null && in_array($this->getAttribute("http-equiv"), self::$strictHttpEquiv)) {
            $this->inspectHttpEquiv($this->getAttribute("http-equiv"), $this->getAttribute("content"));
        }
        if ($this->getAttribute("name") !== null && in_array($this->getAttribute("name"), self::$strictName)) {
            $this->inspectName($this->getAttribute("name"), $this->getAttribute("content"));
        }
        return null;
    }

    private static $strictHttpEquiv = array("cache-control", "refresh");
    private static $validCacheControl = array("public", "private", "no-cache", "no-store");

    private function inspectHttpEquiv($equiv, $content) {
        switch ($equiv) {
            case "cache-control":
                if (!in_array($content, self::$validCacheControl)) {
                    trigger_error("Invalid content set for meta tag 'cache-control'.", E_USER_WARNING);
                }
                break;
            case "refresh":
                if (!is_integer($content)) {
                    trigger_error("Invalid content set for meta tag 'refresh'. Expected integral value.", E_USER_WARNING);
                }
                break;
            default:
                break;
        }
    }

    private static $strictName = array("distribution", "googlebot", "robots");
    private static $validDistribution = array("web", "intranet");
    private static $validGooglebot = array("noarchive", "nofollow", "noindex", "nosnippet");
    private static $validRobots = array("ALL", "FOLLOW", "INDEX", "NOARCHIVE", "NOINDEX", "NOFOLLOW", "NONE");

    private function inspectName($name, $content) {
        switch ($name) {
            case "distribution":
                if (!in_array($content, self::$validDistribution)) {
                    trigger_error("Invalid content in 'distribution' meta tag.", E_USER_WARNING);
                }
                break;
            case "googlebot":
                if (!in_array($content, self::$validGooglebot)) {
                    trigger_error("Invalid content in 'googlebot' meta tag.", E_USER_WARNING);
                }
                break;
            case "robots":
                $split = preg_split("/,/", $content);
                foreach ($split as $item) {
                    if (!in_array($item, self::$validRobots)) {
                        trigger_error("Invalid content '$item' in 'robots' meta tag.", E_USER_WARNING);
                    }
                }
                break;
            default:
                break;
        }
    }

    protected function getTagName() {
        return "meta";
    }

}

class HTMLPage extends HTMLView {

    private $body;
    private $headerScripts = "";

    public function __construct($body = null) {
        if ($body === null) {
            $body = new HTMLBody(null); //They're probably going to add to us later
        } else if ($body instanceof HTMLView) {
            if (!($body instanceof HTMLBody)) {
                $body = new HTMLBody($body);
            }
        } else {
            $body = new HTMLText($body);
        }
        $this->body = $body;
    }

    /**
     * You can use HTMLPage like HTMLBody for the most part, but if you need specific access to the body,
     * you can get to it with this method. 
     */
    public function getBody() {
        return $this->body;
    }

    public function appendContent($view) {
        if (!($view instanceof HTMLView)) {
            $view = new HTMLText($view);
        }
        $this->body->appendContent($view);
        return $this;
    }

    /**
     * Adds a script that will be inlined into the <head> tag.
     * @param type $script 
     */
    public function addHeaderScript($script) {
        $this->headerScripts .= $script . "\n";
        return $this;
    }

    final public function render() {
        $body = $this->body;
        $this->extract($body);
        $render = "";
        $render .= $this->getDoctype();
        $htmlAttributes = $this->getHTMLAttributes();
        $render .= "<html";
        if ($htmlAttributes !== null) {
            $render .= " " . HTMLContainer::SRenderAttributes($htmlAttributes);
        }
        $render .= ">";
        $headAttributes = $this->getHeadAttributes();
        $render .= "<head";
        if ($headAttributes !== null) {
            $render .= " " . HTMLContainer::SRenderAttributes($headAttributes);
        }
        $render .= ">";

        foreach ($this->getMetaTags() as $metaTag) {
            $render .= $metaTag->render();
        }

        foreach ($this->getExternalCSS() as $location) {
            $render .= "<link rel=\"stylesheet\" type=\"text/css\" href=\"$location\" />";
        }

        $renderedCSS = trim(CSSSelectors::render());
        $customCSS = trim($this->getRawCSS());

        if ($renderedCSS != "" || $customCSS != "") {
            $css = new HTMLCSSStyle($renderedCSS . "\n" . $customCSS);
            $render .= $css->render();
        }

        foreach ($this->getExternalScripts() as $script) {
            $s = new HTMLJavaScript();
            $s->setExternal($script);
            $render .= $s->render();
        }
        if (trim($this->headerScripts) != "") {
            $s = new HTMLJavaScript();
            $s->setInline($this->headerScripts);
            $render .= $s->render();
        }

        $render .= "<title";
        if ($this->getTitleAttributes() !== null) {
            $render .= " " . $this->getTitleAttributes();
        }
        $render .= ">" . $this->getTitle() . "</title>";
        $render .= "</head>";
        $render .= $body->render();
        $render .= "</html>";
        return $render;
    }

    protected function getHTMLAttributes() {
        return array("xmlns" => "http://www.w3.org/1999/xhtml", "xml:lang" => "en-us");
    }

    protected function getHeadAttributes() {
        return null;
    }

    protected function getTitleAttributes() {
        return null;
    }

    protected function getDoctype() {
        //$doctype = new HTMLDocType("html", "PUBLIC", "-//W3C//DTD XHTML 1.1//EN", "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd");
        //return $doctype->render();
        //For efficiency sake, we can just return the string, however, highly dynamic subclasses may want to use the above syntax.
        return "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">";
    }

}

class HTMLDocType {

    private $render;

    public function __construct($topElement, $availability = null, $fpi = null, $uri = null) {
        $render = "<!DOCTYPE " . $topElement;
        if ($availability !== null) {
            $render .= " $availability";
        }
        if ($fpi !== null) {
            $render .= " \"$fpi\"";
        }
        if ($uri !== null) {
            $render .= " \"$uri\"";
        }
        $render .= ">";
        return $render;
    }

    public function render() {
        return $this->render;
    }

}

class HTMLStyle extends HTMLContainer {

    public function appendAttribute($name, $content) {
        parent::appendAttribute($name, $content);
        return $this;
    }

    protected function getTagName() {
        return "style";
    }

}

class HTMLCSSStyle extends HTMLStyle {

    public function __construct($content) {
        parent::__construct($content);
        $this->setAttribute("type", "text/css");
    }

}

class HTMLCData extends HTMLView {

    private $data;

    public function __construct($data) {
        $this->data = $data;
    }

    public function render() {
        return "<![CDATA[" . preg_replace('/\]\]>/', ']]>', $this->data) . "]]>";
    }

}

class HTMLScript extends HTMLContainer {

    protected $script;

    /**
     * Creates a new inline script. The tag is never self
     * closed, even if $script is empty.
     * @param type $script 
     */
    public function __construct($script) {
        $this->selfClosed = false;
        $this->script = $script;
    }

    protected function getContent() {
        if (trim($this->script) != "") {
            $cdata = new HTMLCData("//><!--\n" . $this->script . "\n//--><");
            return "<!--//-->" . $cdata->render();
        } else {
            return "";
        }
    }

    protected function getTagName() {
        return "script";
    }

}

class HTMLJavaScript extends HTMLScript {

    /**
     * Creates a new HTMLJavascript element, which can be either internal or external 
     */
    public function __construct() {
        parent::__construct(null);
        $this->setAttribute("type", "text/javascript");
    }

    /**
     * Sets the script to be an external script. If an internal script was already
     * added, it is removed, and a warning is raised.
     * @param type $url 
     */
    public function setExternal($url) {
        if ($this->script != null) {
            trigger_error("Adding external script to element that already has an internal script!", E_USER_WARNING);
        }
        $this->script = null;
        if ($url instanceof URL) {
            $url = $url->build();
        }
        $this->setAttribute("src", $url);
        return $this;
    }

    /**
     * Sets the script to be inline. If an external script was already added, it is removed,
     * and a warning is raised.
     * @param type $script 
     */
    public function setInline($script) {
        if ($this->getAttribute("src") !== null) {
            trigger_error("Adding inline script to element that already has an external script!", E_USER_WARNING);
        }
        $this->script = $script;
        $this->removeAttribute("src");
        return $this;
    }

}

/**
 * The top level HTMLComposite element 
 */
class HTMLBody extends HTMLComposite {

    public function __construct($content) {
        parent::__construct($content);
        $this->selfClosed = false;
    }

    public function appendContent(HTMLView $view) {
        $this->addView($view);
        return $this;
    }

    protected function getContent() {
        $content = parent::getContent();
        $inlineScripts = $this->getInlineScripts();
        if (trim($inlineScripts) != "") {
            //TODO: The javascript can be minified at this point, if desired.
            $content .=
                    '<script type="text/javascript"><!--//--><![CDATA[//><!--' . "\n"
                    . $inlineScripts
                    . "\n//--><]]></script>";
        }
        return new HTMLBlock($content);
    }

    protected function getCompositeTagName() {
        return "body";
    }

}

class HTMLTable extends HTMLComposite {

    private $cells; //Initialized by constructor to contain a 2d array of Views
    private $bodyAttributes = null;
    private $headers = null;
    private $headerRowAttributes = null;
    private $headerCellAttributes = null;
    private $footers = null;
    private $footerRowAttributes = null;
    private $footerCellAttributes = null;
    private $rowRenderer = null;

    /** @param array $cells - A 2D array of View objects */
    public function __construct($cells) {
        $this->cells = $cells;
        if (!is_array($this->cells)) {
            throw new Exception("Expecting an array of arrays to the HTMLTable constructor");
        }
        foreach ($this->cells as $rowKey => $row) {
            if (!is_array($row)) {
                throw new Exception("Expecting an array of arrays to the HTMLTable constructor");
            }
            foreach ($row as $cellKey => $cell) {
                if (!($cell instanceof HTMLTableCell)) {
                    $cell = new HTMLTableCell($cell);
                }
                $this->cells[$rowKey][$cellKey] = $cell;
                $this->addView($cell);
            }
        }
    }

    protected function getCompositeTagName() {
        return "table";
    }

    public function enableBorder($bool) {
        $this->appendAttribute("border", $bool);
        return $this;
    }

    public function setSummary($summary) {
        $this->setAttribute("summary", $summary);
        return $this;
    }

    public function appendAttribute($name, $content) {
        $name = trim($name);
        switch (trim($name)) {
            case "border":
                if ($content == 0) {
                    $this->removeAttribute("border");
                } else {
                    $this->setAttribute("border", 1);
                }
                break;
            case "summary":
                $this->setAttribute("summary", $content);
            default:
                parent::appendAttribute($name, $content);
        }
        return $this;
    }

    protected function getContent() {
        $rendered = "";
        if ($this->headers !== null) {
            $rendered .= "<thead><tr" . ($this->headerRowAttributes !== null ? " " . $this->renderAttributes($this->headerRowAttributes) : "") . ">";
            foreach ($this->headers as $header) {
                if ($this->headerCellAttributes !== null) {
                    $header->addAttributeArray($this->headerCellAttributes);
                }
                $rendered .= $header->render();
            }
            $rendered .= "</tr></thead>";
        }
        if ($this->footers !== null) {
            $rendered .= "<tfoot><tr" . ($this->footerRowAttributes !== null ? " " . $this->renderAttributes($this->headerRowAttributes) : "") . ">";
            foreach ($this->footers as $footer) {
                if ($this->footerCellAttributes !== null) {
                    $footer->addAttributeArray($this->footerCellAttributes);
                }
                $rendered .= $footer->render();
            }
            $rendered .= "</tr></tfoot>";
        }

        if ($this->cells !== null) {
            if ($this->headers !== null || $this->footers !== null) {
                $rendered .= "<tbody>";
            }
            $rowNum = 0;
            foreach ($this->cells as $row) {
                $rendered .= "<tr";
                if ($this->rowRenderer !== null) {
                    $rowRenderer = $this->rowRenderer;
                    $rowAttributes = $rowRenderer($rowNum);
                    if ($rowAttributes != null) {
                        $rendered .= " " . $this->renderAttributes($rowAttributes);
                    }
                }
                $rendered .= ">";
                foreach ($row as $cell) {
                    $rendered .= $cell->render(); //Contains whatever it is this view returns
                }
                $rendered .= "</tr>";
                $rowNum++;
            }
            if ($this->headers !== null || $this->footers !== null) {
                $rendered .= "</tbody>";
            }
        }

        return $rendered;
    }

    /**
     * This accepts an array of HTMLView objects, which is added to the header of the table.
     * @param array[HTMLView] $header 
     */
    public function addHeaderArray(array $header) {
        $this->headers = $header;
        foreach ($header as $key => $cell) {
            if (!($cell instanceof HTMLTableHeaderCell)) {
                $cell = new HTMLTableHeaderCell($cell);
            }
            $this->headers[$key] = $cell;
            $this->addView($cell);
        }
        return $this;
    }

    /**
     * Adds custom attributes to the table header row
     * @param array $headerRowAttributes 
     */
    public function addHeaderRowAttributes(array $headerRowAttributes) {
        if (count($headerRowAttributes) === 0) {
            $this->headerRowAttributes = null;
        } else {
            $this->headerRowAttributes = $headerRowAttributes;
        }
        return $this;
    }

    /**
     * Adds custom attributes to each cell in the header. Usually, you would only use this
     * for style information that is one off for this table, but a css selector in <style> tags in the head
     * is preferred, and for very complex tables, you're better off adding custom HTMLTableHeaderCells yourself.
     * @param array $headerCellAttributes 
     */
    public function addHeaderCellAttributes(array $headerCellAttributes) {
        if (count($headerCellAttributes) === 0) {
            $this->headerCellAttributes = null;
        } else {
            $this->headerCellAttributes = $headerCellAttributes;
        }
        return $this;
    }

    /**
     * Adds custom attributes to the table body
     * @param array $bodyAttributes 
     */
    public function addBodyAttributes(array $bodyAttributes) {
        if (count($bodyAttributes) === 0) {
            $this->bodyAttributes = null;
        } else {
            $this->bodyAttributes = $bodyAttributes;
        }
        return $this;
    }

    /**
     * Adds the footer cells to the table. May be an array of HTMLTableHeaderCells, which are used directly,
     * but if a non-HTMLTableHeaderCell is added, it will be wrapped in a cell for you.
     * @param array $footer 
     */
    public function addFooterArray(array $footer) {
        $this->footers = $footer;
        foreach ($footer as $key => $cell) {
            if (!($cell instanceof HTMLTableHeaderCell)) {
                $cell = new HTMLTableHeaderCell($cell);
            }
            $this->footers[$key] = $cell;
            $this->addView($cell);
        }
        return $this;
    }

    public function addFooterRowAttributes(array $footerAttributes) {
        if (count($footerAttributes) === 0) {
            $this->footerRowAttributes = null;
        } else {
            $this->footerRowAttributes = $footerAttributes;
        }
        return $this;
    }

    /**
     * Adds custom attributes to each cell in the footer. Usually, you would only use this
     * for style information that is one off for this table, but a css selector in <style> tags in the head
     * is preferred, and for very complex tables, you're better off adding custom HTMLTableHeaderCells yourself.
     * @param array $headerCellAttributes 
     */
    public function addFooterCellAttributes(array $footerCellAttributes) {
        if (count($footerCellAttributes) === 0) {
            $this->footerCellAttributes = null;
        } else {
            $this->footerCellAttributes = $footerCellAttributes;
        }
        return $this;
    }

    /**
     * Registers a function that will render attributes for table rows. When a table row
     * is about to be rendered, this function is called and passed the row number (starting with 0). It should
     * then return an associative array with the attributes this row should have. For instance,
     * <pre>
     * function($row){
     *     if($row % 2 == 0) return array("class" => "even");
     * 	   else return array("class" => "odd");
     * }
     * </pre>
     * @param callable $function 
     * @return array
     */
    public function addRowRenderer($function) {
        if (!is_callable($function)) {
            throw new Exception("\$function sent to addRowRenderer is not a callable function!");
        }
        $this->rowRenderer = $function;
        return $this;
    }

}

//TODO: Table rows need to be more editable


class HTMLTableCell extends HTMLContainer {

    public function __construct($content) {
        if ($content instanceof HTMLView) {
            $this->content = $content;
        } else {
            $this->content = new HTMLText($content);
        }
    }

    protected function getTagName() {
        return "td";
    }

    public function setColspan($span) {
        $this->setAttribute("colspan", $span);
        return $this;
    }

    public function setRowspan($span) {
        $this->setAttribute("rowspan", $span);
        return $this;
    }

    public function appendAttribute($name, $content) {
        switch (trim(strtolower($name))) {
            case "colspan":
                $this->removeAttribute("colspan");
                break;
            case "rowspan":
                $this->removeAttribute("rowspan");
                break;
        }
        parent::appendAttribute($name, $content);
        return $this;
    }

}

class HTMLTableHeaderCell extends HTMLTableCell {

    protected function getTagName() {
        return "th";
    }

}

/** HTMLText will render as a span iff there are attributes that have been added to it, otherwise it will not
  render as an html element */
class HTMLText extends HTMLContainer {

    public function __construct($text) {
        $this->content = $text;
    }

    public function render() {
        $attributes = $this->renderAttributes();
        if ($attributes === null || count($attributes) === 0) {
            return $this->getContent();
        } else {
            return parent::render();
        }
    }

    protected function getContent() {
        return htmlentities($this->content);
    }

    /**
     * We are handling render specially, so this won't be used in all cases.
     * @return null 
     */
    protected function getTagName() {
        return "span";
    }

}

/** HTMLBBText extends HTMLText, but also parses BB Code. */
class HTMLBBText extends HTMLText {

    public function __construct($text) {
        parent::__construct($text);
    }

    /** @Override */
    public function render() {
        $rendered = parent::render();
        //Now parse out the BBCode
        $rendered = $this->parseBBCode($rendered);
        return $rendered;
    }

    private function parseBBCode($text) {
        return "This would be BB Parsed: " . $text;
    }

}

class HTMLBlock extends HTMLComposite {

    public function __construct($contents) {
        parent::__construct(func_get_args());
    }

    protected function getCompositeTagName() {
        return "div";
    }

}

class HTMLInline extends HTMLComposite {

    public function __construct($contents) {
        parent::__construct($contents);
    }

    protected function getCompositeTagName() {
        return "span";
    }

}

class URL {

    public $scheme;
    public $host;
    public $port;
    public $user;
    public $pass;
    public $path;
    public $fragment;
    //Use get/setQuery
    private $query;

    public function __construct($url = null) {
        if ($url == null) {
            return; //They may be building it on their own
        }
        $parsed = parse_url($url);
        if ($parsed === false) {
            throw new Exception("Seriously malformed url, and cannot build URL object: $url");
        }
        $this->scheme = $parsed['scheme'];
        $this->host = $parsed['host'];
        $this->port = $parsed['port'];
        $this->user = $parsed['user'];
        $this->pass = $parsed['pass'];
        $this->path = $parsed['path'];
        parse_str($parsed['query'], $this->query);
        $this->fragment = $parsed['fragment'];
    }

    public function getQuery() {
        return $this->query;
    }

    /**
     * Sets the query parameter, overriding the old one(s) if needed. The value is
     * url encoded, so you can send unescaped text. (You may disable this by setting
     * encode to false.)
     * @param type $name
     * @param type $value 
     */
    public function setQueryParam($name, $value, $encode = true) {
        if ($encode) {
            $value = urlencode($value);
        }
        $this->query[$name] = $value;
        return $this;
    }

    /**
     * Adds a query parameter, turning it into an array if needed.
     * @param type $name
     * @param type $value 
     */
//	public function addQueryParam($name, $value) {
//		//TODO: Finish this, if finer granularity is desired
//	}

    /**
     * Returns the value of a query parameter, which could be an array, or null, if nothing is set
     * @param type $name 
     */
    public function getQueryParams($name) {
        if (isset($this->query[$name])) {
            return $this->query[$name];
        } else {
            return null;
        }
    }

    public function build() {
        $render = "";
        $scheme = "";
        if (trim($this->scheme) != "") {
            $scheme = trim($this->scheme);
        }
        if ($scheme != null) {
            $render .= $scheme . '://';
        }
        if ($scheme == "file") {
            $render .= '/';
        }
        if (trim($this->user) != "") {
            $render .= $this->user;
            if (trim($this->pass) != "") {
                $render .= ':' . $this->pass;
            }
            $render .= '@';
        }
        if (trim($this->host) != "") {
            $render .= $this->host;
        }
        if (trim($this->path) != "") {
            $render .= $this->path;
        }
        if (count($this->query) != 0) {
            $render .= "?";
            $first = true;
            foreach ($this->query as $name => $value) {
                if (!$first) {
                    $render .= "&";
                }
                $first = false;
                $render .= $name . '=' . $value;
            }
        }
        if (trim($this->fragment) != "") {
            $render .= '#' . $this->fragment;
        }
        return $render;
    }

}

class HTMLA extends HTMLContainer {
    /**
     * Used by target, opens the link in a new window 
     */

    const _BLANK = "_blank";

    /**
     * Used by target, opens the link in the same frame as it was clicked. This is the default,
     * so it is simply removed from the output if this is what it is set to. 
     */
    const _SELF = "_self";

    /**
     * Used by target, opens the link in the parent frame 
     */
    const _PARENT = "_parent";

    /**
     * Used by target, opens the link in the full body of the window 
     */
    const _TOP = "_top";

    private static $urlRegex = "#((http|https|ftp)://(\S*?\.\S*?))(\s|\;|\)|\]|\[|\{|\}|,|\"|'|:|\<|$|\.\s)#ie";

    public function __construct($content, $href = null) {
        parent::__construct($content);
        if ($href !== null) {
            $this->setHref($href);
        }
    }

    /**
     * This does not encode the url, so you must do that yourself. Alternatively, use
     * the URL object, and guarantee the url will be properly encoded.
     * @param type $href 
     */
    public function setHref($href) {
        $this->appendAttribute("href", $href);
        return $this;
    }

    public function getHref() {
        return $this->getAttribute("href");
    }

    /**
     * Sets the target of this link. Note that using the target attribute causes validation errors,
     * however you must use javascript to get around that problem, which may not always
     * be acceptable as a solution.
     * @param type $target 
     */
    public function setTarget($target) {
        $this->appendAttribute("target", $target);
        return $this;
    }

    public function getTarget() {
        return $this->getAttribute("target");
    }

    public function appendAttribute($name, $content) {
        if ($name == "href") {
            $this->removeAttribute("href");
            if ($content instanceof URL) {
                $content = $content->build();
            }
        }
        if ($name == "target") {
            $this->removeAttribute("target");
            //_self is the default target, so we can just remove it entirely.
            if ($content == self::_SELF) {
                return;
            }
        }
        parent::appendAttribute($name, $content);
        return $this;
    }

    public function getTagName() {
        return "a";
    }

}

class HTMLListItem extends HTMLComposite{    
    protected function getCompositeTagName() {
        return "li";
    }
}

abstract class HTMLList extends HTMLComposite{
    public function __construct(array $list){
        foreach($list as $li){
            if(!($li instanceof HTMLListItem)){
                $li = new HTMLListItem($li);
            }
            $this->addView($li);
        }
    }
}
class HTMLOrderedList extends HTMLList{    
    protected function getCompositeTagName() {
        return "ol";
    }
}
class HTMLUnorderedlist extends HTMLList{    
    protected function getCompositeTagName() {
        return "ul";
    }
}

class HTMLImg extends HTMLContainer {

    public function __construct($src, $alt, $width = null, $height = null) {
        if (!isset($alt)) {
            trigger_error("No alt text provided for the image at $src", E_USER_WARNING);
        }
        //Self closed, so nothing should be put in the contents
        $this->setAttribute("src", $src);
        $this->setAttribute("alt", $alt);
        if ($width !== null)
            $this->setAttribute("width", $width);
        if ($height !== null)
            $this->setAttribute("height", $height);
    }

    protected function getTagName() {
        return "img";
    }

}

/**
 * Represents an input of some sort. Subclasses provide more specific functionality, and this
 * class should normally not be instantiated directly.
 */
abstract class HTMLInput extends HTMLComposite {

    const BUTTON = "button";
    const CHECKBOX = "checkbox";
    const FILE = "file";
    const HIDDEN = "hidden";
    const IMAGE = "image";
    const PASSWORD = "password";
    const RADIO = "radio";
    const RESET = "reset";
    const SUBMIT = "submit";
    const TEXT = "text";

    protected function __construct($type, $name, $value) {
        $this->setAttribute("type", $type);
        $this->setAttribute("name", $name);
        $this->setAttribute("value", $value);
    }

    public function setDisabled($disabled) {
        if ($disabled) {
            $this->setAttribute("disabled", "disabled");
        } else {
            $this->removeAttribute("disabled");
        }
        return $this;
    }

    public function appendAttribute($name, $content) {
        if ($name == "type") {
            $this->removeAttribute("type");
            switch ($content) {
                case self::BUTTON:
                case self::CHECKBOX:
                case self::FILE:
                case self::HIDDEN:
                case self::IMAGE:
                case self::PASSWORD:
                case self::RADIO:
                case self::RESET:
                case self::SUBMIT:
                case self::TEXT:
                    break;
                default:
                    trigger_error("Input type '$content' is not recognized as a valid type.", E_USER_WARNING);
                    break;
            }
        }
        switch ($name) {
            case "accept":
            case "align":
            case "alt":
            case "checked":
            case "src":
                if ($this->acceptableAttributes() === null || !in_array($name, $this->acceptableAttributes())) {
                    trigger_error("Attribute '$name' is not allowed in this input type.", E_USER_WARNING);
                }
                break;
            default:
                break;
        }
        parent::appendAttribute($name, $content);
        return $this;
    }

    protected function getCompositeTagName() {
        return "input";
    }

    /**
     * By default, the following attribute types are restricted to just a few input types:
     * accept, align, alt, checked, and src. Unless the subtype returns a list of acceptable
     * types to override this check, those attributes are not allowed to be added.
     * @return null 
     */
    protected function acceptableAttributes() {
        return null;
    }

}

//These classes represent the trivial input types
class HTMLHiddenInput extends HTMLInput {

    public function __construct($name, $value) {
        parent::__construct(HTMLInput::HIDDEN, $name, $value);
    }

}

class HTMLTextInput extends HTMLInput {

    public function __construct($name, $value = "") {
        parent::__construct(HTMLInput::TEXT, $name, $value);
    }

}

class HTMLButtonInput extends HTMLInput {

    public function __construct($name, $value) {
        parent::__construct(HTMLInput::BUTTON, $name, $value);
    }

}

class HTMLPasswordInput extends HTMLInput {

    public function __construct($name, $value = "") {
        parent::__construct(HTMLInput::PASSWORD, $name, $value);
    }

}

class HTMLFileInput extends HTMLInput {

    private static $acceptable = array("accept");

    public function __construct($name) {
        parent::__construct(HTMLInput::FILE, $name, "");
    }

    protected function acceptableAttributes() {
        return self::$acceptable;
    }

}

class HTMLImageInput extends HTMLInput {

    private static $acceptable = array("align", "alt", "src");

    public function __construct($name, $value) {
        parent::__construct(HTMLInput::IMAGE, $name, $value);
    }

    protected function acceptableAttributes() {
        return self::$acceptable;
    }

}

class HTMLResetInput extends HTMLInput {

    public function __construct($name) {
        parent::__construct(HTMLInput::RESET, $name, "");
        $this->removeAttribute("value");
    }

}

class HTMLSubmitInput extends HTMLInput {

    public static $SubmitText = "Submit";

    public function __construct($name = null, $value = null) {
        if ($value === null) {
            $value = self::$SubmitText;
        }
        parent::__construct(HTMLInput::SUBMIT, $name, $value);
    }

}

/**
 * You probably want to use the HTMLRadioGroup instead of this, however, if you need
 * more flexibility in specifying the radio group, you may use this class directly.
 */
class HTMLRadioInput extends HTMLInput {

    private static $acceptable = array("checked");

    public function __construct($name, $value, $selected = false) {
        parent::__construct(HTMLInput::RADIO, $name, $value);
        $this->setSelected($selected);
    }

    public function setSelected($selected) {
        if ($selected) {
            $this->setAttribute("checked", "checked");
        } else {
            $this->removeAttribute("checked");
        }
    }

    protected function acceptableAttributes() {
        return self::$acceptable;
    }

}

class HTMLRadioGroup extends HTMLFlatComposite {

    /**
     * Constructs a logical radio button group, with the name given, using the options
     * array as $value => $text. If $useFor is true, a random id will be generated and
     * used on the input as well, to associate the label with the radio button. If
     * $blockLevel is true, it will put each radio button into it's own div as well.
     * @param type $groupName
     * @param array $options 
     */
    public function __construct($groupName, array $options, $selectedValue = null, $useFor = true, $blockLevel = true) {

        foreach ($options as $value => $text) {
            $radio = new HTMLRadioInput($groupName, $value);
            if ($value == $selectedValue) {
                $radio->setSelected(true);
            }
            if ($useFor) {
                $id = $this->getRandomId();
                $radio->setId($id);
                $label = new HTMLLabel($id, $text);
            } else {
                $label = new HTMLText(" " . $text);
            }
            if ($blockLevel) {
                $block = new HTMLBlock(array($radio, $label));
                $this->addView($block);
            } else {
                $this->addView($radio);
                $this->addView($label);
            }
        }
    }

}

//These are the more complex input types
/**
 * This class automatically adds a label to the checkbox, using the <label> tag,
 * which will make the user experience better. Using this label feature
 * will automatically set the id of the checkbox to $name, since an id is
 * required by label. If the label is null, no
 * label tag will be generated, and you are free to do your own label, 
 * for instance, if multiple forms with the same name exist on the page.
 */
class HTMLCheckboxInput extends HTMLInput {

    private static $acceptable = array("checked");
    private $alignRight = true;
    private $label = null;

    protected function acceptableAttributes() {
        return self::$acceptable;
    }

    public function __construct($name, $label, $checked = false) {
        parent::__construct(HTMLInput::CHECKBOX, $name, "");
        $this->label = $label;
        if ($this->label !== null) {
            $this->setId($name);
        }
        $this->removeAttribute("value");
        if ($checked) {
            $this->setAttribute("checked", "checked");
        }
    }

    public function setLabel($label, $alignRight = true) {
        $this->label = $label;
        $this->alignRight = $alignRight;
        return $this;
    }

    public function render() {
        $rendered = "";
        $label = "";
        if ($this->label !== null) {
            $label = new HTMLLabel($this->getAttribute("name"), $this->label);
            $label = $label->render();
        }
        if ($this->alignRight) {
            $rendered .= parent::render();
            $rendered .= $label;
        } else {
            $rendered .= $label;
            $rendered .= parent::render();
        }
        return $rendered;
    }

}

final class HTMLLabel extends HTMLContainer {

    public function __construct($for, $content) {
        parent::__construct($content);
        $this->setFor($for);
    }

    public function setFor($for) {
        $this->setAttribute("for", $for);
        return $this;
    }

    public function getFor() {
        return $this->getAttribute("for");
    }

    public function appendAttribute($name, $content) {
        if ($name == "for") {
            $this->removeAttribute("for");
        }
        parent::appendAttribute($name, $content);
        return $this;
    }

    protected function getTagName() {
        return "label";
    }

}

class HTMLLegend extends HTMLContainer {

    protected function getTagName() {
        return "legend";
    }

}

class HTMLFieldset extends HTMLComposite {

    private $fieldsetName = null;

    public function __construct($content, $name = null) {
        parent::__construct($content);
        $this->fieldsetName = $name;
    }

    public function setFieldsetName($name) {
        $this->fieldsetName = $name;
        return $this;
    }

    public function getContent() {
        if ($this->fieldsetName !== null) {
            $this->addView(new HTMLLegend($this->fieldsetName));
        }
        return parent::getContent();
    }

    protected function getCompositeTagName() {
        return "fieldset";
    }

}

/**
 * An HTML form contains various user input mechanisms, which are sent back to the server to be processed.
 * This class makes formatting the form quick and easy. 
 */
class HTMLForm extends HTMLComposite {

    const POST = "post";
    const GET = "get";

    private $fieldsetName = null;

    /**
     * Send an associative array of form name-value pairs, and they will automatically be added
     * to the form.
     * @param array $inputs 
     */
    public function addHiddenInputs(array $inputs) {
        foreach ($inputs as $name => $value) {
            $this->addView(new HTMLHiddenInput($name, $value));
        }
        return $this;
    }

    public function addViews($view, $_) {
        foreach (func_get_args() as $arg) {
            if (is_array($arg)) {
                foreach ($arg as $a) {
                    $this->addViews($a);
                }
            } else {
                if (!($arg instanceof HTMLView)) {
                    $arg = new HTMLText($arg);
                }
                $this->addView($arg);
            }
        }
        return $this;
    }

    public function addView(HTMLView $view) {
        parent::addView($view);
        return $this;
    }

    /**
     * Creates a new form, which will submit to the specified page, defaulting to the current page.
     * @param type $action 
     */
    public function __construct($action = "") {
        $this->setAttribute("action", $action);
    }

    public function setMethod($method) {
        $this->setAttribute("method", $method);
        return $this;
    }

    public function getMethod() {
        return $this->getAttribute("method");
    }

    public function setAction($action) {
        $this->setAttribute("action", $action);
        return $this;
    }

    public function getAction() {
        return $this->getAttribute("action");
    }

    public function getContent() {
        $content = parent::getContent();
        if ($this->fieldsetName !== null) {
            $fieldset = new HTMLFieldset($content, $this->fieldsetName);
            return $fieldset->render();
        } else {
            return new HTMLBlock($content);
        }
    }

    /**
     * Puts a fieldset around an entire form. This does not
     * preclude you from adding your own fieldset elements, this
     * is just a convenience mechanism for setting the fieldset if
     * this form is one single fieldset.
     * @param type $name 
     */
    public function setFieldsetName($name) {
        $this->fieldsetName = $name;
        return $this;
    }

    public function appendAttribute($name, $content) {
        if ($name == "action") {
            $this->removeAttribute("action");
        }
        if ($content instanceof URL) {
            $content = $content->build();
        }
        if ($name == "method") {
            if ($content != self::GET && $content != self::POST) {
                trigger_error("Setting method to invalid value, only 'get' and 'post' are acceptable.", E_USER_WARNING);
            }
        }
        parent::appendAttribute($name, $content);
        return $this;
    }

    /**
     * Returns all the input objects contained in this form.
     * @return \HTMLInput 
     */
    public function getAllInputs() {
        $inputs = array();
        foreach ($this->getAllViews() as $view) {
            if ($view instanceof HTMLInput) {
                $inputs[] = $view;
            }
        }
        return $inputs;
    }

    /**
     * Returns an array of name=>type, indicating all the inputs inside of this form. This can be used to auto-fill
     * missing form elements with the default condition, should the parameter not be sent, such as what happens
     * with checkboxes that are not checked.
     * @return type 
     */
    public function getAllInputNames() {
        $inputNames = array();
        foreach ($this->getAllInputs() as $input) {
            $inputNames[$input->getAttribute("name")] = $input->getAttribute("type");
        }
        return array_unique($inputNames);
    }

    protected function getCompositeTagName() {
        return "form";
    }

}

/**
 * A macro class that creates Submit, Reset, and Cancel buttons which (probably) would be at the bottom of a form. 
 * The strings that are used by default are public static variables, or they can be overridden on a per-instance
 * basis by sending the text each time. $cancelAction should be the url they go to if the click the cancel button. If
 * javascript is disabled, they may be on a standalone page with just the form as the view, otherwise, it will probably
 * be a dialog box, in which case, it will simply close.
 */
class HTMLSubmitResetCancelInput extends HTMLFlatComposite {

    public static $SubmitText = "Submit";
    public static $ResetText = "Reset";
    public static $CancelText = "Cancel";

    /**
     * Creates a new Submit | Reset | Cancel button group. This button group has special behavior if this is
     * included as part of a managed form.
     * @param string $cancelPage The url of the page that the user will be sent to if they hit the cancel button. Typcially
     * this would be the same page, so the default is "".
     * @param string $cancelView The view to go to when cancel is pressed. If the main view, you may leave it at it's default, null.
     * @param string $submitText The text to put in the submit button. If null, it uses the HTMLSubmitResetCancelInput::$SubmitText variable,
     * which defaults to "Submit", but can be globally changed, as it is a public static variable.
     * @param string $resetText The text to put in the reset button. If null, it uses the HTMLSubmitResetCancelInput::$ResetText variable,
     * which defaults to "Reset", but can be globally changed, as it is a public static variable.
     * @param string $cancelText The text to put in the Cancel button. If null, it uses the HTMLSubmitResetCancelInput::$CancelText variable,
     * which defaults to "Cancel", but can be globally changed, as it is a public static variable.
     */
    public function __construct($cancelPage = "", $cancelView = null, $submitText = null, $resetText = null, $cancelText = null) {
        if ($submitText === null) {
            $submitText = self::$SubmitText;
        }
        if ($resetText === null) {
            $resetText = self::$ResetText;
        }
        if ($cancelText === null) {
            $cancelText = self::$CancelText;
        }
        $this->addView(new HTMLSubmitInput(null, $submitText));
        $this->addView(new HTMLResetInput($resetText));
        $url = $cancelPage;
        if (!($url instanceof URL)) {
            $url = new URL($url);
        }
        $urlView = $url->getQueryParams("_view");
        if ($urlView != null && $urlView != $cancelView) {
            trigger_error("Do not set the view in the url passed with \$cancelPage to the HTMLSubmitResetCancelInput view.", E_USER_WARNING);
        }
        if ($cancelView != "") {
            $url->setQueryParam("_view", $cancelView);
        }
        $a = new HTMLA(new HTMLButtonInput("cancel", $cancelText), $url->build());
        $a->addStyle("text-decoration", "none");
        $a->addClass("autoCancel");
        $this->addView($a);
    }

    /**
     * If this control block is being used in a managed form, you should set the view to show when the cancel
     * button is clicked, if this does not go to the default view.
     * @param type $view 
     */
    public function setCancelView($view) {
        $a = $this->views[2];
        $url = new URL($a->getHref());
        $url->setQueryParam("_view", $view);
        $a->setHref($url->build());
        return $this;
    }

}

/**
 * Creates a form that will cause the page to refresh and show the specified view. If the view specified is shown, and
 * this button is embedded in a managed dialog, the dialog will simply close. 
 */
class HTMLShowViewButton extends HTMLView {

    private $form;

    public function __construct($viewName, $buttonText) {
        $form = new HTMLForm();
        $form->setMethod(HTMLForm::POST);
        $form->addHiddenInputs(array("_view" => $viewName));
        $form->addView(new HTMLSubmitInput(null, $buttonText));
        $form->addClass("--intercept");
        $form->addClass("--show-view");
        $this->form = $form;
    }

    public function render() {
        return $this->form->render();
    }

}

abstract class HTMLShowFormControl extends HTMLView {

    protected $component;

    public function render() {
        return $this->component->render();
    }

}

class HTMLShowFormButton extends HTMLShowFormControl {

    public function __construct($formName, $buttonText) {
        $form = new HTMLForm();
        $form->setMethod(HTMLForm::POST);
        $form->addClass("--intercept");
        $form->addClass("--show-form");
        $form->addClass("---$formName");
        $form->addView(new HTMLSubmitInput(null, $buttonText));
        $form->addHiddenInputs(array("_fallback" => $formName));
        $this->component = $form;
    }

}

class HTMLShowFormLink extends HTMLShowFormControl {

    public function __construct($formName, $linkText) {
        $href = "?_fallback=" . urlencode($formName);
        $a = new HTMLA($linkText, $href);
        $a->addClass("-intercept");
        $a->addClass("--show-form");
        $a->addClass("---$formName");
        $this->component = $a;
    }

}

class HTMLFormOptions {

    /**
     * If a request can be handled asynchronously, (and javascript is enabled) this form will be submitted
     * asynchronously, and if the request was successful, it will simply clear the form (and do other
     * managed actions). If the form is managed and shown in a dialog, the dialog will be closed.
     * @var type 
     */
    public $isAsync = true;

    /**
     * If a form is activated by a HTMLFormActivator button press, instead of showing the component in
     * its own view, it is shown in a modal dialog instead. Usually if this is true, $isAsync should
     * also be true for best results. If this is false, isAsync is irrelevant, the page simply
     * redirects as if javascript were off.
     * @var type 
     */
    public $useDialog = true;

    /**
     * These are the options that will be sent to the jQuery dialog box if the dialog is shown.
     * @var type 
     */
    public $dialogOptions = array();

    /**
     * Before the form can be submitted, javascript will be used to validate the inputs that have declared
     * validation parameters. These parameters will also be automatically validated by the server upon form
     * submission, and further validation may occur as well.
     * @var type 
     */
    public $validateFirst = true;

    /**
     * Sets the javascript and server side validation options. This should be an associative array mapping
     * input name=>validation options, where validation options is an associative array with one or more of
     * the following key=>value pairs:
     * 		type:
     * 			one of either: string, numeric, or integral
     * 		minval:
     * 			if type is numeric or integral, defines the minimum value that is acceptable.
     * 		maxval:
     * 			if type is numeric or integral, defines the maximum value that is acceptable.
     * 		minlen:
     * 			if type is string, defines the minimum length value that is acceptable.
     * 		maxlen:
     * 			if type is string, defines the maximimum length value that is acceptable
     * 		regex:
     * 			if type is string, defines the regex pattern that this must match to be considered acceptable.
     * 		error:
     * 			A string, representing the error message to display if this value is not acceptable for whatever reason.
     * 			A generic message will be provided if this is not set.
     * @var type 
     */
    public $validationOptions = array();

}

/**
 * This class contains options that can be set on a view, which is passed in with
 * registerView in HTMLPageManager. 
 */
class HTMLViewOptions {

    /**
     * If an invalid view is requested, (or no view at all) if this view is the
     * default view, it will be shown. If more
     * than one default view is provided, it is an error, and a warning will be shown.
     * If no view is specified as the default, the first one is assumed to be the default.
     * @var boolean 
     */
    public $defaultView = false;

    /**
     * Some views can be shown regardless of previous actions. If the view needs to validate
     * parameters before it is shown, it can set this to a callback function, and it will
     * be called before the requested view is shown. If the function returns normally, it will
     * be shown, if it throws an exception, the exception's error message will be displayed instead.
     * @var callable 
     */
    public $validateFirst = null;

}

class HTMLValidationException extends Exception {

    private $errors;

    public function __construct(array $errors) {
        $this->errors = $errors;
    }

    public function getErrors() {
        return $this->errors;
    }

}

final class HTMLPageManager {

    private static $reservedRequestVars = array("_view", "_action", "_ajax", "_managed", "_regen", "_fallback");
    private $_view;
    private $_action;
    private $_ajax;
    private $_managed;
    private $_regen;
    private $_fallback;
    private $defaultHTMLViewOptions = null;
    private $defaultView = null;
    private $handled = false;
    private $views = null;
    private $viewOptions = null;
    private $components = null;
    private $forms = null;
    private $formCallbacks = null;
    private $formOptions = null;
    private $actionHandler = null;
    private $wrapperGenerator = null;

    public function __construct() {
        $this->views = array();
        $this->viewOptions = array();
        $this->components = array();
        $this->forms = array();
        $this->formCallbacks = array();
        $this->formOptions = array();
        $this->req = array();
    }

    public function __destruct() {
        if (!$this->handled) {
            trigger_error("Page Manager constructed, but not invoked. Did you forget to call \$PageManager->handle()? If you purposely meant to"
                    . " ignore this object, call \$PageManager->ignore() to supress this warning.", E_USER_WARNING);
        }
    }

    /**
     *  
     */
    public function ignore() {
        $this->handled = true;
    }

    /**
     * This looks at the request variables to decide what view to show, and how it needs to be shown. If the request was
     * a managed ajax request, it will also be handled.
     */
    public function handle() {
        foreach (self::$reservedRequestVars as $var) {
            if (isset($_REQUEST[$var])) {
                $varVal = $_REQUEST[$var];
                unset($_REQUEST[$var]);
                unset($_POST[$var]);
                unset($_GET[$var]);
                switch ($var) {
                    case "_view":
                        $this->_view = $varVal;
                        break;
                    case "_action":
                        $this->_action = $varVal;
                        break;
                    case "_ajax":
                        $this->_ajax = $varVal;
                        break;
                    case "_managed":
                        $this->_managed = $varVal;
                        break;
                    case "_regen":
                        $this->_regen = $varVal;
                        break;
                    case "_fallback":
                        $this->_fallback = $varVal;
                        break;
                    default:
                        break;
                }
            }
        }

        $this->handled = true;
        if (isset($this->_fallback)) {
            //It's a form fallback, we need to generate the form, display it, then return.			
            $content = null;
            $form = $this->getComponent($this->_fallback);
            $this->prepareForm($this->_fallback, $form);
            if ($this->wrapperGenerator === null) {
                trigger_error("No wrapper generator was provided, using barebones page instead.", E_USER_WARNING);
                $content = new HTMLPage($form);
            } else {
                $content = call_user_func($this->wrapperGenerator, $this, $form);
            }
            $content->display();
            return;
        }
        if (isset($this->_action)) {
            //It's a request that needs action, if it's managed, then it's a form submission (ajax or otherwise)
            //and if it's not, we need to pass the action on to the generic action handler.
            if (isset($this->_managed)) {
                if (isset($this->formCallbacks[$this->_action])) {
                    //We need to fill in the missing parameters that are supposed to be in this form, but are not
                    //(checkboxes have this behavior, for instance)
                    foreach ($this->getComponent($this->_action)->getAllInputNames() as $name => $type) {
                        if ($type == HTMLInput::CHECKBOX) {
                            if (!isset($_REQUEST[$name])) {
                                $_REQUEST[$name] = false;
                            }
                        }
                    }
                    $errors = array();
                    if (isset($this->formOptions[$this->_action]->validationOptions)) {
                        $errors = array_merge($errors, $this->doValidation($_REQUEST, $this->formOptions[$this->_action]->validationOptions));
                    }
                    try {
                        //This function can throw an exception, which will 
                        call_user_func($this->formCallbacks[$this->_action], $_REQUEST);
                    } catch (HTMLValidationException $e) {
                        $errors = array_merge($errors, $e->getErrors());
                    }
                    if (count($errors) > 0) {
                        
                    }
                } else {
                    trigger_error("No callback function registered for the form '{$this->_action}'", E_USER_WARNING);
                }
            } else {
                if ($this->actionHandler instanceof Closure) {
                    call_user_func($this->actionHandler, $this->_action);
                } else {
                    trigger_error("A custom action was sent, but the action handler has not been set", E_USER_NOTICE);
                }
            }
        }
        if (isset($this->_ajax)) {
            //It's an ajax request, and it may want to regen some components
            //TODO
        } else {
            //This is a full blown view
            $this->defaultHTMLViewOptions = new HTMLViewOptions();
            $viewToRender = $this->defaultView;
            $viewOptions = $this->defaultHTMLViewOptions;
            $requestedView = $this->_view;
            if (isset($requestedView)) {
                if (isset($this->views[$requestedView])) {
                    $viewToRender = $this->views[$requestedView];
                }
            }
            if (isset($this->viewOptions[$requestedView])) {
                $viewOptions = $this->viewOptions[$requestedView];
            }

            if ($viewOptions->validateFirst instanceof Closure) {
                try {
                    call_user_func($viewOptions->validateFirst, $this);
                    //We're good, we can continue rendering this view
                } catch (Exception $e) {
                    //This will be thrown if the validateFirst callback threw an exception
                    $this->error($e->getMessage());
                    die();
                }
            }
            $view = call_user_func($viewToRender, $this);
            if (!($view instanceof HTMLPage)) {
                trigger_error("Attempting to display a non-HTMLPage in the view manager. Make sure that the callbacks"
                        . " you registered with registerView returns an HTMLPage object.", E_USER_WARNING);
                return;
            } else {
                //We need to add our dialog-able forms here now, so they will be able to be shown in a dialog
                foreach ($this->forms as $formName) {
                    $form = $this->getComponent($formName);
                    $this->prepareForm($formName, $form);
                    if (isset($this->formOptions[$formName]) && $this->formOptions[$formName]->useDialog) {
                        $form->addExternalScript(CommonIncludes::JQuery);
                        $form->addExternalScript(CommonIncludes::JQueryUI);
                        $form->addExternalScript(CommonIncludes::ViewCore);
                        $form->addExternalCSS(CommonIncludes::JQueryCSS);
                        $form->addStyle("display", "none");
                        $view->appendContent($form);
                    }
                    $this->validateValidationParams($form, $this->formOptions[$formName]->validationOptions);
                }
                if (count($this->forms) > 0) {
                    foreach ($this->forms as $formName) {
                        if (isset($this->formOptions[$formName])) {
                            $view->addHeaderScript("VC.addFormOptions(\"$formName\", " . json_encode($this->formOptions[$formName]) . ");\n");
                        }
                    }
                }
                $view->display();
            }
        }
    }

    /**
     * Validates the validationOptions array passed in, since it's a bit complex, and easy to fat finger. We will
     * also fill in missing options, so further steps can make assumptions to reduce code complexity elsewhere.
     * @param type $formName
     * @param type $params 
     */
    private function validateValidationParams(HTMLForm $form, array &$params) {
        foreach ($params as $name => $options) {
            if (!isset($options['type'])) {
                trigger_error("Type not set in validationOptions for '$name'");
            } else {
                $type = strtolower($options['type']);
                if ($type == "int") {
                    $type = "integral";
                }
                if ($type == "double") {
                    $type = "numeric";
                }
                switch ($type) {
                    case "string":
                        if (isset($options['minval']) || isset($options['maxval'])) {
                            trigger_error("minval and maxval should not be added to a validation parameter of type string.", E_USER_WARNING);
                        }
                        break;
                    case "integral":
                    case "numeric":
                        if (isset($options['minlen']) || isset($options['maxlen'])) {
                            trigger_error("minlen and maxlen should not be added to a validation parameter of type integral or numeric.", E_USER_WARNING);
                        }
                        break;
                    default:
                        trigger_error("Invalid type specified: '$type'.", E_USER_WARNING);
                        break;
                }
            }
        }
    }

    /**
     * When a form is automatically managed, we need to add a few parameters to the request. These parameters will
     * not be passed to the handler, they will be removed prior.
     * @param HTMLForm $form 
     */
    private function prepareForm($formName, $form) {
        if (!($form instanceof HTMLForm)) {
            trigger_error("The form generator registered with addForm must return an HTMLForm object", E_USER_WARNING);
        }
        $form->addHiddenInputs(array("_managed" => true, "_action" => $formName));
    }

    private function error($msg) {
        //TODO
        die($msg);
    }

    /**
     * A component is a section that can be regenerated with an ajax request, standalone from the rest of the page. It 
     * can also be displayed separately from the rest of the page, should javascript be disabled. Views should use
     * getComponent() to retrieve the component from this PageManager, so the display of this view will always
     * be consistent. $componentGenerator should be a callback function that returns an HTMLView, which will only 
     * be rendered if needed.
     */
    public function addComponent($name, $componentGenerator) {
        if ($componentGenerator instanceof Closure) {
            $this->components[$name] = $componentGenerator;
        } else {
            trigger_error("Closure not provided to addComponent.", E_USER_WARNING);
        }
        return $this;
    }

    /**
     * Retrieves a registered component. All components should be registered each time, regardless of if they are used,
     * because otherwise there is the chance calling this function will trigger a warning.
     * @param type $name 
     * 
     * @return string The generated HTMLView
     */
    public function getComponent($name, $arguments = array()) {
        if (isset($this->components[$name])) {
            return call_user_func_array($this->components[$name], array_merge(array($this), $arguments));
        } else {
            trigger_error("Requested the '$name' component, but that component doesn't exist!", E_USER_WARNING);
            return null;
        }
    }

    /**
     * Adds a managed form element to the page. Works like addComponent, but it will also register the form
     * for automatic management, which means that it will submit the form via ajax. Additionally, you must
     * register a callback handler, which will handle the input from the form once it is submitted, either
     * via ajax or not; the manager will handle that for you. The callback will recieve an array with the
     * parameters submitted via the form, and it needn't check the $_REQUEST variables directly. Once
     * registered, this component can be retrieved via getComponent.
     * @param type $name
     * @param HTMLPageComponent $form 
     */
    public function addForm($name, $formGenerator, $callback, /* HTMLFormOptions */ $options = null) {
        if ($formGenerator instanceof Closure) {
            $this->components[$name] = $formGenerator;
            $this->forms[] = $name;
            $this->formCallbacks[$name] = $callback;
            if ($options !== null) {
                $this->formOptions[$name] = $options;
            } else {
                $this->formOptions[$name] = new HTMLFormOptions();
            }
        } else {
            trigger_error("Closure not provided to addForm", E_USER_WARNING);
        }
        return $this;
    }

    /**
     * This registers an HTMLView as an eligable view. A view is a standard layout of components
     * that will be shown, given a request for the particular view. The $options are an HTMLViewOptions
     * object, which is used to specify managed behavior per view. $viewGenerator is a callback that should
     * return a single HTMLPage object which will end up being displayed if this view was requested.
     * 
     * @param HTMLViewOptions $options
     */
    public function registerView($name, $viewGenerator, $options = null) {
        if ($viewGenerator instanceof Closure) {
            $this->views[$name] = $viewGenerator;
            if ($this->defaultView === null) {
                $this->defaultView = $viewGenerator;
            }
            if ($options !== null) {
                $this->viewOptions[$name] = $options;
                if ($options->defaultView) {
                    $this->defaultView = $viewGenerator;
                }
            }
        } else {
            trigger_error("Closure not provided to registerView", E_USER_WARNING);
        }
        return $this;
    }

    /**
     * An action handler is used to handle generic action requests to the server. If a form is added with
     * the addForm method, that form will be automatically managed, but javascript (or forms) may submit
     * for custom actions as well, and then the function provided is called. The signature of the handler
     * should be function($action), $action will be set to the action provided, by the request inputs, and
     * 
     * @param type $handler 
     */
    public function setActionHandler($handler) {
        //TODO
        return $this;
    }

    /**
     * For forms that support falling back, the wrapper is used to generate the frame around the form itself.
     * This should be a callback function that will recieve the generated content as an HTMLView: function($contents).
     * @param type $wrapper 
     */
    public function setWrapperGenerator($wrapper) {
        if ($wrapper instanceof Closure) {
            $this->wrapperGenerator = $wrapper;
        } else {
            trigger_error("setWrapperGenerator expects a closure", E_USER_WARNING);
        }
        return $this;
    }

    /**
     * In some cases, such as in a custom action handler, you may wish to force a particular
     * view to be shown. If this is the case, calling this function will force that view to
     * be displayed, checking to see if this is an ajax request, and if so, commanding the
     * javascript to refresh the page to the given view.
     * @param type $view 
     */
    public function displayView($view) {
        if ($this->_ajax) {
            $this->javascriptControl("showView", $view);
        } else {
            $view = $this->views[$view];
            $view = call_user_func($view, $this);
            $view->display();
        }
    }

    /**
     * If this is an ajax request, issues a command to the javascript, then dies. If not
     * an ajax request, triggers a warning, then dies anyways. Though javascript of course
     * cannot be relied on to listen to the command, for non-secure actions, it is a reasonable
     * assumption to make that the javascript will listen.
     * @param type $command
     * @param type $params 
     */
    private function javascriptControl($command, $params) {
        $args = func_get_args();
        unset($args[0]); //That's the command
        //TODO
    }

    private function doValidation($request, $options) {
        $errors = array();
        foreach ($options as $input => $option) {
            $errorMsg = "";
            $failValidation = false;
            $val = $request[$input];
            if ($option['type'] == 'string') {
                $hasMinLen = false;
                if (isset($option["minlen"])) {
                    $hasMinLen = true;
                    if (strlen($val) < $option['minlen']) {
                        $failValidation = true;
                    }
                }
                $hasMaxLen = false;
                if (isset($option["maxlen"])) {
                    $hasMaxLen = true;
                    if (strlen($val) > $option['maxlen']) {
                        $failValidation = true;
                    }
                }
                if ($hasMaxLen && $hasMinLen) {
                    if ($option['minlen'] == $option['maxlen']) {
                        $errorMsg = "You must enter exactly " . $option['minlen'] . " character" . ($option['minlen'] == 1 ? "" : "s") . ".";
                    } else {
                        $errorMsg = "You must enter between " . $option['minlen'] . "-" . $option['maxlen'] . " characters.";
                    }
                } else if ($hasMaxLen) {
                    $errorMsg = "You must enter no more than " . $option['maxlen'] . " characters.";
                } else if ($hasMinLen) {
                    $errorMsg = "You must enter at least " . $option['minlen'] . " characters.";
                }
            } else if ($option['type'] == 'numeric' || $option['type'] == 'integer') {
                //TODO: Mirror the javascript implementation
            }
            if ($failValidation) {
                $errors[] = $errorMsg;
            }
        }
        return $errors;
    }

}

class CommonIncludes {
    //Javascript
    const ViewCore = "js/lib/viewcore.js";
    const JQuery = "http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js";
    const JQueryUI = "http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js";

    //CSS
    const JQueryCSS = "css/ui-lightness/jquery-ui-1.8.20.custom.css";

}

//A CRUD interface would likely be able to generate a 2D array for us, but we'll generate one real quick
//This information would be pulled from the model, as needed
function getArrayFromModel() {
    $array = array();
    if (!isset($_SESSION['showEntities'])) {
        $_SESSION['showEntities'] = true;
    }
    if (!isset($_SESSION['radioButton'])) {
        $_SESSION['radioButton'] = "two";
    }
    for ($i = 0; $i < 5; $i++) {
        $inner = array();
        for ($j = 0; $j < 5; $j++) {
            $inner[] = "$i $j" . ($_SESSION['showEntities'] ? " <escaped entities>" : "") . " " . $_SESSION['radioButton'];
        }
        $array[] = $inner;
    }
    return $array;
}

function setModelData($showEntities, $radioButton) {
    $_SESSION['showEntities'] = $showEntities;
    $_SESSION['radioButton'] = $radioButton;
}

session_start();
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// For convenience, everything is in one file, but the code below is the only thing that would be in the controller, normally
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
$manager = new HTMLPageManager();

$manager->addComponent("table", function($manager) {
    $array = getArrayFromModel();
    $array[0][0] = new HTMLA($array[0][0], "http://www.google.com");
    $array[0][1] = date("G:i.s");
    $table = new HTMLTable($array);
    //Add Our header/footer and attributes
    $table->addCSSBlock("table thead tr th", array("background-color" => "purple"));
    $table->addCSSBlock("table tfoot tr th", array("background-color" => "green"));
    $table->addCSSBlock(".odd td", array("background-color" => "gray"));
    $table->addFooterArray(array("This", "is", "the", "footer", "yay"));
    $table->addHeaderArray(array("This", "is", "the", "header", "yay"));
    //We do want the border
    $table->enableBorder(true);
    $table->setId("hi");

    //We want custom rendering per row
    $table->addRowRenderer(function($num) {
                if ($num % 2 == 0) {
                    return array("class" => "odd");
                } else {
                    return array("class" => "even");
                }
            });
    return $table;
});

$formOptions = new HTMLFormOptions();
$formOptions->dialogOptions = array("modal" => "true");
$formOptions->validationOptions = array("text" => array('type' => 'string', 'minlen' => '2'));
$formOptions->isAsync = false;
//$formOptions->regen = array("table");
$manager->addForm("form", function($manager) {
    $form = new HTMLForm();    
    $form->addView(new HTMLBlock(new HTMLCheckboxInput("name", "Hi!", true)));
    $form->addView(new HTMLBlock(new HTMLRadioGroup("radio", array("one" => "One", "two" => "Two", "three" => "Three"), "two")));
    $form->addView(new HTMLBlock("Text: ", new HTMLTextInput("text")));
    $form->addView(new HTMLSubmitResetCancelInput("", ""));
    $form->setFieldsetName("Fieldset");
    $form->setMethod(HTMLForm::POST);
    return $form;
}, function($req) {
    setModelData($req['name'], $req['radio']);
}, $formOptions);

$manager->registerView("main", function($manager) {
    //Now, let's create the page, and add our table to it.
    $frame = new HTMLPage();
    $frame->setPageTitle("Title")->
            addMetaTag(new HTMLMeta("This is the page", "description"));
    $img = new HTMLImg("http://www.w3schools.com/images/compatible_firefox.gif", "firefox logo");
    $frame->appendContent($img)-> //If we didn't provide alt text, this would give an error    
            appendContent($manager->getComponent("table"))-> //Adds the table to the content area of the page
            appendContent(new HTMLShowFormButton("form", "Show Form"))->
            appendContent(new HTMLBlock(new HTMLShowViewButton("view2", "Go to View 2")));
    return $frame;
});

$manager->registerView("view2", function($manager) {
    $frame = new HTMLPage();
    $frame->setPageTitle("View 2")->
            appendContent(new HTMLShowViewButton("main", "Go back to main view"))->
            appendContent($manager->getComponent("table"))->
            appendContent(new HTMLUnorderedlist(array("bat", "cat", "hat")))->
            appendContent(new HTMLOrderedList(array("one", "two", "three")));
    return $frame;
});

$manager->setWrapperGenerator(function($manager, $content) {
    $page = new HTMLPage($content);
    $page->setPageTitle($title);
    return $page;
});

$manager->handle();
?>
